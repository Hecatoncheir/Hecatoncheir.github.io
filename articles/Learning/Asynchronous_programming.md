
Мы рассмотрим передовые технологии, которые помогут нам работать с асинхронным кодом - одним из самых важнейших компонентов Dart. Асинхронное программирование является стандартной парадигмой программирования вместе с объектно-ориентированными принципами и играет важную роль в разработке приложений.

<p><a href="/#article/The_Dart_Vm_execution_model">Про модель исполнения кода в Dart VM можно прочитать здесь.</a></p>

Для лучшего понимания асинхронного программирования в Dart мы рассмотрим архитектуры **стека вызова (call-stack)** и **управляемых событий (event-driven)**. 

## Call-stack архитектура
Традиционно, программы строятся на концепции **стека вызовов**. Эта концепция очень проста, потому как программа в основном выполняет и вызывает последовательные операции. Каждая операция может выполнить другую операцию. В момент вызова программа создаёт контекст для выполняемой операции. Вызвавшая операция будет ждать пока вызываемая операция закончит работу и тогда программа сможет вернуть контекст для продолжения её выполнения. Вызываемая операция со своей стороны может выполнять ещё операцию.

Программа создаёт стек вызова для координации и управления контекстом каждого вызова. Основные примитивы этой концепции - вызовы (calls). Все вызовы в программе тесно связанны, потому что программа знает какие операции должны быть вызваны после текущей вызываемой операции и может поделить одну и ту же память. Архитектура стека вызова очень распространена и популярна, потому что очень похожа на архитектуру процессоров.

## Event-driven архитектура
Архитектура управляемых событий полная противоположность концепции стека вызова. Основные примитивы этой концепции - события (events). Система отправляет события и передает их среди слабосвязанных компонентов программного обеспечения и ёё служб. К преимуществам **event-driven архитектуры (EDA)** можно отнести следующее:

- помогает использовать существующие ресурсы эффективно;
- архитектура проста в расширении, развитии и поддержке, снижая стоимость обслуживания;
- позволяет обмениваться сообщениями в асинхронном режиме, что предотвращает блокировку или ожидание очереди;
- слабая связь между производящим кодом и выполняющим;

Взаимодействие между компонентами ограничено лишь производящей событие операции и одним или несколькими выполняющими. Операции, производящие события, чувствуют себя свободно от проблем параллелизма и проблем синхронизации. Выполняющие операции могут быть изменены в любой момент, так как производящие и выполняющие операции слабо связанны друг с другом. 

> **Заметка**: Событийная архитектура это правильный выбор для разработки слабозависимых асинхронных систем.

<br><br>

## Синхронный и асинхронный код
Есть много разговоров о том, какой код лучше синхронный или асинхронный. Все разговоры останавливаются на дизайне архитектуры. Следовательно, важным вопросом будет разница в синхронных и асинхронных конструкциях кода?

Обсудим условия того, что мы будем делать. Операции будут выполняться последовательно в синхронном **(sync)** коде. Не больше, не меньше. Это очень популярно, потому что это просто. Логика синхронного кода ясна и мы можем прочитать и понять его без особых усилий. Взглянем на следующий фрагмент кода:

```dart

import 'dart:io';

main() {
  try {
    File file = new File("data.txt");
    RandomAccessFile handler = file.openSync();
    List<int> content = handler.readSync(handler.lengthSync());
    String contentAsString = new String.fromCharCodes(content);
    print("Content:  $contentAsString");
    handler.closeSync();
  } on FileSystemException catch(e) {
    print(e.message);
  }
}

```

<p class="column">
Во-первых, мы создаем переменную указывающую на файл <em>data.txt</em> в файловой системе. Далее, мы создаём обработчик открыв этот файл. Затем, обработчик считывает байты открытого файла в переменную <em>content</em>. И на конец, мы переводим содержание переменной <em>content</em> в строку, печатаем результат и закрываем обработчик для файла. Некоторые операции в этом коде занимают больше времени чем другие. Операция чтения файла может быть быстрой только в случаях, когда размер файла маленький. Если файл большой, то программа будет ожидать пока файл не будет считан. Для перевода содержимого файла может потребоваться некоторое время. Такие операции блокируют выполнение нашей программы; каждый раз такая операция должна завершаться до того, как начнётся выполнение другой. Такой код реализован на синхронный манер и может быть полезен при выполнении простых задач таких как эта. Тем не менее, такой подход не может быть применён в комплексном программном обеспечении. Комплексная программа может иметь различные части кода, которые могут взаимодействовать между собой для обеспечения удобного интерфейса пользователя <strong>(UI)</strong>, обработки процесса ввода с клавиатуры, для чтения информации с удалённого сайта и в тоже время записи информации в файл. Таким образом, пришло время обсудить модный асинхронный <strong>(async)</strong> код. Асинхронный код не ждёт завершения каждой операции. Результат каждой операции будет обработан позже, когда станет доступным. Асинхронный код использует несколько важных классов в Dart SDK и один из них <strong>Future</strong>.
</p>

## Future (будущее)
Изменим предыдущий код на асинхронный, как показано ниже:

```dart

import 'dart:io';

main() {
  File file = new File("data.txt");
  file.open().then(processFile);
}

processFile(RandomAccessFile file) {
  file.length().then((int length) {
    file.read(length).then(readFile).whenComplete(() {
      file.close();
    });
  });
  }

readFile(List<int> content) {
  String contentAsString = new String.fromCharCodes(content);
  print("Content:  $contentAsString");
}

```

<p class="column">
Как можно заметить, класс <strong>Future</strong> указывает на первоначально неизвестный результат и возвращает значение вместо того, что бы вызвать функцию обратного вызова. <em>Future</em> может быть создано отдельно или с <em>Completer</em>. В различных ситуациях должны быть использованы различные способы создания <em>Future</em>. Разделение задач между <em>Future</em> и <em>Completer</em> может оказаться очень полезным. С одной стороны мы можем передать <em>Future</em> нескольким выполняющим код сущностям для того, что бы они могли независимо друг от друга решить что с ним делать дальше. С другой стороны, им может быть передан <em>Completer</em> и тогда будущее значение (Future) будет выполнено той сущностью, которая сможет сделать это первой. В конечном итоге <em>Future</em> предоставляет значение, которое возвращается обработчиком функции обратного вызова (callback) и <strong>может быть представлено в одном из следующих состояний:
</strong></p>

- начальное состояние, когда *Future* ожидает результат. Атрибут *result* содержит список прослушивающих *Future*;
- законченное состояние со значением в результате;
- законченное состояние с ошибкой в результате;
- класс *Future* возвращается в ожидании выполнения или переданного состояния в цепи, или переданного другому классу *Future* при завершении с успехом или ошибкой. Будет выводить сообщение об ошибке, если вы попытаетесь завершить будущее значение снова;

> **Заметка:** **Future** может быть завершено со значениeм или ошибкой только один раз.

Исполняющая операция может зарегистрировать функцию обратного вызова для обработки полученного в результате ошибки или значения.

Я немного изменил пример для управления исключениями и намеренно указал неправильное имя файла, что бы заставить программу бросить исключение:

```dart

main() {
  File file = new File("data1.txt");
  file.open().then(processFile).catchError((error, stackTrace) {
    print("Ошибочный результат $error\n$stackTrace");
  }, test:(error) {
    return error is FileSystemException;
  }).whenComplete((){
    print("Файл закрыт");
  });
}

```

В предыдущем коде мы добавили метод **catchError** для обработки ошибок. Обратите внимание на необязательный параметр **test** метода *catchError*. Этот параметр является функцией и будет вызван первым в случае завершения *Future* с ошибкой. Таким образом у нас есть возможность проверить, должна ли ошибка обрабатываться в *catchError*. Если этот параметр пропущен, то по умолчанию будет определена функция, которая всегда возвращает **true**. Если этот необязательный параметр *test* возвращает *true*, функция, определённая в первом параметре метода *catchError*, вызывается с ошибкой и по возможности с **трассировкой стека (stack trace)**, и возвращает завершённое будущее значение и результат вызова этой функции. Полученное исключение будет иметь, примерно, такой вид:

```bash
Catched error is FileSystemException: Cannot open file, path = 'data1.txt' (OS Error: The system cannot find the file specified.
, errno = 2)
#0     _File.open.<anonymous closure> (dart:io/file_impl.dart:349)
#1     _RootZone.runUnary (dart:async/zone.dart:1082)
//…
File closed
```

Если необязательный параметр *test* вернёт *false*, исключение не будет обработано методом *catchError* и вернёт завершеное *Future* значение с той же ошибкой и трассировкой стека.

> **Заметка:** метод **catchError** это асинхронный эквивалент **catch** блока.
Последнее, но не менее важное **Future** класс имеет **whenComplete** метод. Этот метод имеет один параметр - функцию, которая всегда вызывается в конце, независимо от будущего результата. 

> **Заметка:** метод **whenComplete** это асинхронный эквивалент **finally** блока.

Рассмотрим различные конструкторы **Future**.

## Future и Timer
Создадим класс *Future*, который будет содержать результат вызываемых асинхронно вычислений с методом *run* класса **Timer**:

```dart
Future calc = new Future(computation);
calc.then((res) => print(res));
```

Этот *Future*  класс не завершится мгновенно. Класс *Timer* добавляет событие в очередь событий и выполняет вычисления (computation), когда событие начнёт обрабатываться в цикле событий. Если результат вычисления (computation) вызывет ошибку, будущее значение *Future* будет завершено с этой же ошибкой. Если функция вычисления (computation) создает еще одно *Future*, то первое *Future* будет ожидать завершения нового и затем будет завершено с тем же результатом.

## Future и микротаски (Microtask)
В следующем коде, *Future* это запланированная по расписанию задача в очереди *microtask*, которая не начнёт завершаться сразу же:
```dart
Future calc = new Future.microtask(computation);
calc.then((res) => print(res));
```

Если результат выполнения *computation* вызывет ошибку, возвращаемое *Future* тоже завершится с ошибкой. Если computation создает еще одно *Future*, то первое *Future* будет ожидать завершения нового и затем будет завершено с тем же результатом.

## Синхронизация будущего (класса *Future*)
Это может звучать парадоксально, но мы можем создать синхронную версию класса *Future*:

```dart
Future calc = new Future.sync(computation);
calc.then((res) => print(res));
```
Таким образом *Future* немедленно вызывает *computation* функцию. Результат вычислений computation будет возвращен в следующей итерации цикла событий.

## Значение для *Future*
*Future* может быть создано вместе с определённым значением:
```dart
Future valueFuture = new Future.value(true);
valueFuture.then((res) => print(res));
```
Вот так, *Future* возвращает определённое значение в следующей итерации цикла событий.

## *Future* с сообщением об ошибке
*Future* может быть создано с какой-нибудь ошибкой:
```dart
try {
  throw new Error();
} on Error catch(ex, stackTrace) {
  Future errorFuture = new Future.error(ex, stackTrace);
  errorFuture.catchError((err, stack) => print(err));
}
```

В следующей итерации цикла событий *Future* уже будет завершено с ошибкой.

## Задержка класса *Future*
Иногда может понадобится завершить *Future* с задержкой. Это можно сделать так:
```dart
Future calc = new Future.delayed(
      new Duration(seconds:1), computation);
calc.then((res) => print(res));
```

*Future* будет завершено по истечению установленного времени задержки с результатом выполнения функции *computation*. Такая конструкция всегда создает событие в очереди событий и событие начинает завершаться не раньше следующей итерации цикла событий, даже если задержка указана ноль или меньше.

>**Заметка:** Ошибка или значение завершённое в классе *Future* не должно изменяться для избежания побочных эффектов в операциях прослушивающих события.

Если *Future* некому обработать, любая произошедшая ошибка может пройти не замеченной. Для предотвращения этих случаев, Dart направляет ошибку в глобальный обработчик событий.

## Плюсы класса Future:
- последовательная обработка исключений и функций обратного вызова;
- это более удобный способ по сравнению с выполнением цепочки операций;
- Future легко объединять;
- обеспечивает единый управляемый поток для разработки web и приложений командной строки;

Теперь становится понятно почему Dart повсюду использует Future в своём API.